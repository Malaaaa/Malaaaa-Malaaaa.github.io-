"use strict";(self.webpackChunkblog_sample=self.webpackChunkblog_sample||[]).push([[757],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return m}});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var u=a.createContext({}),o=function(e){var t=a.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=o(e.components);return a.createElement(u.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,s=e.originalType,u=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),c=o(n),m=r,g=c["".concat(u,".").concat(m)]||c[m]||d[m]||s;return n?a.createElement(g,i(i({ref:t},p),{},{components:n})):a.createElement(g,i({ref:t},p))}));function m(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=n.length,i=new Array(s);i[0]=c;var l={};for(var u in t)hasOwnProperty.call(t,u)&&(l[u]=t[u]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var o=2;o<s;o++)i[o]=n[o];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"},978:function(e,t,n){n.r(t),n.d(t,{assets:function(){return p},contentTitle:function(){return u},default:function(){return m},frontMatter:function(){return l},metadata:function(){return o},toc:function(){return d}});var a=n(7462),r=n(3366),s=(n(7294),n(3905)),i=["components"],l={},u="Flux de contr\xf4le exceptionnel",o={unversionedId:"CSAPP/Exceptional Control Flow",id:"CSAPP/Exceptional Control Flow",title:"Flux de contr\xf4le exceptionnel",description:"Les exceptions sont une forme de flux de contr\xf4le exceptionnel qui sont mis en \u0153uvre en partie par le mat\xe9riel eten partie par le syst\xe8me d'exploitation. \\ Une exception est un changement brusque dans le flux de contr\xf4le en r\xe9ponse \xe0 un certain changement dans l'\xe9tat du processeur.",source:"@site/i18n/fr/docusaurus-plugin-content-docs/current/CSAPP/Exceptional Control Flow.md",sourceDirName:"CSAPP",slug:"/CSAPP/Exceptional Control Flow",permalink:"/fr/docs/CSAPP/Exceptional Control Flow",draft:!1,editUrl:"https://github.com/Malaaaa/blog-sample/tree/main/docs/CSAPP/Exceptional Control Flow.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Syst\xe8mes informatiques",permalink:"/fr/docs/CSAPP/CSAPPNOTE"},next:{title:"O",permalink:"/fr/docs/CSAPP/I/O"}},p={},d=[{value:"Gestion des interruptions.",id:"gestion-des-interruptions",level:2},{value:"Manipulation des pi\xe8ges.",id:"manipulation-des-pi\xe8ges",level:2},{value:"Traitement des pannes.",id:"traitement-des-pannes",level:2},{value:"Abandonner la manipulation.",id:"abandonner-la-manipulation",level:2},{value:"Exceptions Linux/x86-64 dans le syst\xe8me",id:"exceptions-linuxx86-64-dans-le-syst\xe8me",level:3},{value:"\xc9checs et arr\xeats Linux/x86-64",id:"\xe9checs-et-arr\xeats-linuxx86-64",level:3},{value:"Appels syst\xe8me Linux/x86-64",id:"appels-syst\xe8me-linuxx86-64",level:3},{value:"Fourchette",id:"fourchette",level:3}],c={toc:d};function m(e){var t=e.components,l=(0,r.Z)(e,i);return(0,s.kt)("wrapper",(0,a.Z)({},c,l,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"flux-de-contr\xf4le-exceptionnel"},"Flux de contr\xf4le exceptionnel"),(0,s.kt)("p",null,"Les exceptions sont une forme de flux de contr\xf4le exceptionnel qui sont mis en \u0153uvre en partie par le mat\xe9riel*",(0,s.kt)("strong",{parentName:"p"},"* et"),"en partie par le syst\xe8me d'exploitation.** \\ Une exception est un changement brusque dans le flux de contr\xf4le en r\xe9ponse \xe0 un certain changement dans l'\xe9tat du processeur."),(0,s.kt)("p",null,"Les exceptions asynchrones sont g\xe9n\xe9r\xe9es par des \xe9v\xe9nements dans les p\xe9riph\xe9riques d'E/S externes au processeur. Les exceptions synchrones sont le produit direct de l'ex\xe9cution d'une instruction."),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"Anatomie d&#39;une exception",src:n(7810).Z,width:"924",height:"492"})," Lorsque le syst\xe8me d'exploitation d\xe9marre, une table de sauts appel\xe9e table d'exceptions est allou\xe9e et initialis\xe9e."),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"img_12.png",src:n(9136).Z,width:"964",height:"796"})),(0,s.kt)("h2",{id:"gestion-des-interruptions"},"Gestion des interruptions."),(0,s.kt)("p",null,"Les p\xe9riph\xe9riques d'E/S/OI, tels que les adaptateurs r\xe9seau, les contr\xf4leurs de disque et les puces de minuterie, d\xe9clenchent une interruption en signalant une broche sur la puce du processeur et en pla\xe7ant un num\xe9ro d'exception sur le bus syst\xe8me qui identifie le p\xe9riph\xe9rique \xe0 l'origine de l'interruption."),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"img_13.png",src:n(3777).Z,width:"964",height:"406"})," Une fois l'ex\xe9cution de l'instruction en cours termin\xe9e, le processeur remarque que la tension au niveau de la broche d'interruption est \xe9lev\xe9e, lit le num\xe9ro d'exception sur le bus syst\xe8me, puis appelle le gestionnaire d'interruption appropri\xe9. Lorsque le gestionnaire revient, il rend le contr\xf4le \xe0 l'instruction suivante (c'est-\xe0-dire celle qui aurait suivi l'instruction en cours dans le flux de contr\xf4le si l'interruption ne s'\xe9tait pas produite). Le r\xe9sultat est que le programme continue de s'ex\xe9cuter comme si l'interruption ne s'\xe9tait pas produite."),(0,s.kt)("p",null,"Les types d'exception restants (d\xe9routement, erreur et terminaison) se produisent de mani\xe8re synchrone et r\xe9sultent de l'ex\xe9cution de l'instruction en cours. Nous appelons ce type d'instruction une instruction fautive."),(0,s.kt)("h2",{id:"manipulation-des-pi\xe8ges"},"Manipulation des pi\xe8ges."),(0,s.kt)("p",null,"Les interruptions sont des exceptions intentionnelles r\xe9sultant de l'ex\xe9cution d'une instruction. Tout comme les gestionnaires d'interruptions, les gestionnaires d'interruptions rendent le contr\xf4le \xe0 l'instruction suivante. L'utilisation la plus importante des interruptions consiste \xe0 fournir une interface de type proc\xe9dure entre le programme utilisateur et le noyau, appel\xe9e appel syst\xe8me. Les programmes utilisateur ont souvent besoin de demander des services au noyau, tels que la lecture d'un fichier (read), la cr\xe9ation d'un nouveau processus (fork), le chargement d'un nouveau programme (execve) ou l'arr\xeat du processus en cours (exit). Pour permettre un acc\xe8s contr\xf4l\xe9 \xe0 ces services du noyau, le processeur fournit une instruction sp\xe9ciale \"syscall n\" qui peut \xeatre ex\xe9cut\xe9e lorsqu'un programme utilisateur souhaite demander le service n. L'ex\xe9cution de l'instruction syscall entra\xeene une interruption vers un gestionnaire d'exceptions qui r\xe9sout les arguments et appelle le programme de noyau appropri\xe9."),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"img_14.png",src:n(80).Z,width:"944",height:"336"})," Du point de vue d'un programmeur, les appels syst\xe8me et les appels de fonction normaux sont les m\xeames. Cependant, ils sont mis en \u0153uvre tr\xe8s diff\xe9remment. Les fonctions ordinaires s'ex\xe9cutent en mode utilisateur, ce qui limite les types d'instructions qu'une fonction peut ex\xe9cuter, et elles ne peuvent acc\xe9der qu'\xe0 la m\xeame pile que la fonction appelante. Les appels syst\xe8me s'ex\xe9cutent en mode noyau, ce qui permet aux appels syst\xe8me d'ex\xe9cuter des instructions privil\xe9gi\xe9es et d'acc\xe9der \xe0 la pile d\xe9finie dans le noyau."),(0,s.kt)("h2",{id:"traitement-des-pannes"},"Traitement des pannes."),(0,s.kt)("p",null,"L'erreur est caus\xe9e par une condition d'erreur, qui peut \xeatre corrig\xe9e par le gestionnaire d'erreurs. Lorsqu'un d\xe9faut se produit, le processeur transf\xe8re le contr\xf4le au gestionnaire de d\xe9fauts. Si le gestionnaire est capable de corriger la condition d'erreur, il rend le contr\xf4le \xe0 l'instruction qui a provoqu\xe9 l'erreur et la r\xe9ex\xe9cute ainsi. Sinon, le gestionnaire retourne \xe0 la routine d'abandon dans le noyau, et la routine d'abandon met fin \xe0 l'application qui a caus\xe9 l'erreur. ",(0,s.kt)("img",{alt:"img_15.png",src:n(4070).Z,width:"970",height:"326"})),(0,s.kt)("h2",{id:"abandonner-la-manipulation"},"Abandonner la manipulation."),(0,s.kt)("p",null,"L'arr\xeat est le r\xe9sultat d'une erreur fatale irr\xe9cup\xe9rable, g\xe9n\xe9ralement une erreur mat\xe9rielle telle qu'une erreur de parit\xe9 qui se produit lorsqu'un bit DRAM ou SRAM est corrompu. Le gestionnaire de terminaison ne rend jamais le contr\xf4le \xe0 l'application. ",(0,s.kt)("img",{alt:"img_16.png",src:n(5834).Z,width:"1010",height:"324"})),(0,s.kt)("h3",{id:"exceptions-linuxx86-64-dans-le-syst\xe8me"},"Exceptions Linux/x86-64 dans le syst\xe8me"),(0,s.kt)("p",null,"Les nombres 0 \u223c 31 correspondent \xe0 des exceptions d\xe9finies par les architectes d'Intel et sont donc les m\xeames pour tout syst\xe8me x86-64. 32 \u223c 255 correspondent aux interruptions et traps d\xe9finis par le syst\xe8me d'exploitation."),(0,s.kt)("table",null,(0,s.kt)("thead",{parentName:"table"},(0,s.kt)("tr",{parentName:"thead"},(0,s.kt)("th",{parentName:"tr",align:"left"},"Num\xe9ro d'exception"),(0,s.kt)("th",{parentName:"tr",align:"left"},"La description"),(0,s.kt)("th",{parentName:"tr",align:"left"},"Classe Exozone"))),(0,s.kt)("tbody",{parentName:"table"},(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"left"},"0"),(0,s.kt)("td",{parentName:"tr",align:"left"},"erreur de division"),(0,s.kt)("td",{parentName:"tr",align:"left"},"faute")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"left"},"13"),(0,s.kt)("td",{parentName:"tr",align:"left"},"D\xe9faut de protection g\xe9n\xe9rale"),(0,s.kt)("td",{parentName:"tr",align:"left"},"Faute")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"left"},"14"),(0,s.kt)("td",{parentName:"tr",align:"left"},"Page manquante"),(0,s.kt)("td",{parentName:"tr",align:"left"},"faute")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"left"},"18"),(0,s.kt)("td",{parentName:"tr",align:"left"},"V\xe9rification des machines"),(0,s.kt)("td",{parentName:"tr",align:"left"},"Avorter")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"left"},"32 ~ 255"),(0,s.kt)("td",{parentName:"tr",align:"left"},"Exceptions d\xe9finies par le syst\xe8me d'exploitation"),(0,s.kt)("td",{parentName:"tr",align:"left"},"Interruptions ou pi\xe8ges")))),(0,s.kt)("h3",{id:"\xe9checs-et-arr\xeats-linuxx86-64"},"\xc9checs et arr\xeats Linux/x86-64"),(0,s.kt)("p",null,"Erreur de division (exception 0). Une tentative de division par z\xe9ro a donn\xe9 un r\xe9sultat trop grand pour l'op\xe9rande cible. Exception virgule flottante (Floating exception) D\xe9faut de protection g\xe9n\xe9rale (Exception 13). Une zone ind\xe9finie de m\xe9moire virtuelle a \xe9t\xe9 r\xe9f\xe9renc\xe9e ou parce que le programme a tent\xe9 d'\xe9crire un segment de texte en lecture seule. \"D\xe9faut de segmentation (D\xe9faut de segmentation)\" Page manquante (Exception 14). Will re-execute Le gestionnaire mappe une page de m\xe9moire virtuelle sur le disque appropri\xe9 vers une page de m\xe9moire physique, puis r\xe9ex\xe9cute cette instruction qui a g\xe9n\xe9r\xe9 l'erreur. Machine check (Exception 18) Se produit lorsqu'une erreur mat\xe9rielle fatale est d\xe9tect\xe9e. Ne rend jamais le contr\xf4le \xe0 l'application."),(0,s.kt)("h3",{id:"appels-syst\xe8me-linuxx86-64"},"Appels syst\xe8me Linux/x86-64"),(0,s.kt)("p",null,"Linux Linux fournit des centaines d'appels syst\xe8me qui peuvent \xeatre utilis\xe9s lorsqu'une application souhaite demander un service du noyau, y compris la lecture d'un fichier, l'\xe9criture d'un fichier ou la cr\xe9ation d'un nouveau processus."),(0,s.kt)("table",null,(0,s.kt)("thead",{parentName:"table"},(0,s.kt)("tr",{parentName:"thead"},(0,s.kt)("th",{parentName:"tr",align:"right"},"num\xe9ro"),(0,s.kt)("th",{parentName:"tr",align:"center"},"Nom"),(0,s.kt)("th",{parentName:"tr",align:"center"},"la description"),(0,s.kt)("th",{parentName:"tr",align:"center"},"num\xe9ro"),(0,s.kt)("th",{parentName:"tr",align:"center"},"Nom"),(0,s.kt)("th",{parentName:"tr",align:"left"},"la description"))),(0,s.kt)("tbody",{parentName:"table"},(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"right"},"0"),(0,s.kt)("td",{parentName:"tr",align:"center"},"lire"),(0,s.kt)("td",{parentName:"tr",align:"center"},"lire le dossier"),(0,s.kt)("td",{parentName:"tr",align:"center"},"33"),(0,s.kt)("td",{parentName:"tr",align:"center"},"pause"),(0,s.kt)("td",{parentName:"tr",align:"left"},"suspendre le processus jusqu'\xe0 ce que le signal arrive")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"right"},"1"),(0,s.kt)("td",{parentName:"tr",align:"center"},"\xe9crivez"),(0,s.kt)("td",{parentName:"tr",align:"center"},"\xe9crire le fichier"),(0,s.kt)("td",{parentName:"tr",align:"center"},"37"),(0,s.kt)("td",{parentName:"tr",align:"center"},"alarme"),(0,s.kt)("td",{parentName:"tr",align:"left"},"planifier la transmission du signal d'alarme")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"right"},"2"),(0,s.kt)("td",{parentName:"tr",align:"center"},"ouvrir"),(0,s.kt)("td",{parentName:"tr",align:"center"},"ouvrir le fichier"),(0,s.kt)("td",{parentName:"tr",align:"center"},"39"),(0,s.kt)("td",{parentName:"tr",align:"center"},"getpid"),(0,s.kt)("td",{parentName:"tr",align:"left"},"obtenir l'ID du processus")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"right"},"3"),(0,s.kt)("td",{parentName:"tr",align:"center"},"Fermer"),(0,s.kt)("td",{parentName:"tr",align:"center"},"fermer le dossier"),(0,s.kt)("td",{parentName:"tr",align:"center"},"57"),(0,s.kt)("td",{parentName:"tr",align:"center"},"fourchette"),(0,s.kt)("td",{parentName:"tr",align:"left"},"cr\xe9er le processus")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"right"},"4"),(0,s.kt)("td",{parentName:"tr",align:"center"},"statistique"),(0,s.kt)("td",{parentName:"tr",align:"center"},"Obtenir des informations sur le fichier"),(0,s.kt)("td",{parentName:"tr",align:"center"},"59"),(0,s.kt)("td",{parentName:"tr",align:"center"},"ex\xe9cuter"),(0,s.kt)("td",{parentName:"tr",align:"left"},"Ex\xe9cuter un programme")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"right"},"9"),(0,s.kt)("td",{parentName:"tr",align:"center"},"mmap"),(0,s.kt)("td",{parentName:"tr",align:"center"},"mapper des pages de m\xe9moire \xe0 un fichier"),(0,s.kt)("td",{parentName:"tr",align:"center"},"60"),(0,s.kt)("td",{parentName:"tr",align:"center"},"sortir"),(0,s.kt)("td",{parentName:"tr",align:"left"},"terminer un processus")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"right"},"12"),(0,s.kt)("td",{parentName:"tr",align:"center"},"brk"),(0,s.kt)("td",{parentName:"tr",align:"center"},"r\xe9initialiser le haut du tas"),(0,s.kt)("td",{parentName:"tr",align:"center"},"61"),(0,s.kt)("td",{parentName:"tr",align:"center"},"attendre4"),(0,s.kt)("td",{parentName:"tr",align:"left"},"attendre qu'un processus se termine")),(0,s.kt)("tr",{parentName:"tbody"},(0,s.kt)("td",{parentName:"tr",align:"right"},"32"),(0,s.kt)("td",{parentName:"tr",align:"center"},"dup2"),(0,s.kt)("td",{parentName:"tr",align:"center"},"Copier un descripteur de fichier"),(0,s.kt)("td",{parentName:"tr",align:"center"},"62"),(0,s.kt)("td",{parentName:"tr",align:"center"},"tuer"),(0,s.kt)("td",{parentName:"tr",align:"left"},"Envoyer un signal \xe0 un processus")))),(0,s.kt)("p",null,"Les programmes C peuvent appeler n'importe quel appel syst\xe8me directement avec la fonction syscall."),(0,s.kt)("p",null,"Sur IA32, l'appel syst\xe8me Linux est appel\xe9 sys_call() via l'interruption int 0x80, qui acc\xe8de \xe0 la table des vecteurs d'interruption. Il transmet le num\xe9ro d'appel syst\xe8me via eax\xa0; une s\xe9rie d'autres registres transmettent les param\xe8tres, stock\xe9s dans ebx, ecx, edx, esi, edi, ebp\xa0; et la valeur de retour est stock\xe9e dans eax. L'architecture x86 64 introduit une instruction sp\xe9ciale, syscall, qui n'acc\xe8de pas \xe0 la table des descripteurs d'interruption et est beaucoup plus rapide. Il transmet le num\xe9ro d'appel syst\xe8me via rax\xa0; une s\xe9rie d'autres registres transmettent les param\xe8tres (6), stock\xe9s dans rdi, rsi, rdx, r10, r8, r9 ; la valeur de retour est stock\xe9e dans rax."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell"},'#include <unistd_32.h>\nint main()\n{\n    write(1, "bonjour, monde\\n", 13);\n    _exit(0);\n}\n')),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-as"},".section .data\ncha\xeene\xa0:\n  .ascii \"hello, world\\n\"\nstring_end\xa0:\n  .equ len, string_end - cha\xeene\n.section .text\n.globl main\nmain\xa0:\n  , world\\n\", 13)\n  movq $1, %rax # write est l'appel syst\xe8me 1\n  movq $1, %rdi # Arg1\xa0: stdout a le descripteur 1\n  movq $string, %rsi # Arg2\xa0: hello world string\n  movq $len, %rdx # Arg3\xa0: longueur de la cha\xeene\n  syscall # Effectuez l'appel syst\xe8me\n\n  # Ensuite, appelez _exit(0)\n  movq $60, %rax # _exit est l'appel syst\xe8me 60\n  movq $0, %rdi # Arg1\xa0: l'\xe9tat de sortie est 0\n  syscall # Make l'appel syst\xe8me\n")),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Un processus fournit \xe0 chaque programme son propre espace d'adressage priv\xe9.")),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"img_17.png",src:n(6519).Z,width:"922",height:"882"})," La partie inf\xe9rieure de l'espace d'adressage est r\xe9serv\xe9e au programme utilisateur, avec les segments habituels de code, de donn\xe9es, de tas et de pile. Le segment de code commence toujours \xe0 l'adresse 0x400000. La partie sup\xe9rieure de l'espace d'adressage est r\xe9serv\xe9e au noyau (la partie r\xe9sidente en m\xe9moire du syst\xe8me d'exploitation). Cette partie de l'espace d'adressage contient le code, les donn\xe9es et la pile que le noyau utilise lorsqu'il ex\xe9cute les instructions pour le compte du processus (par exemple, lorsque le programme d'application ex\xe9cute un appel syst\xe8me )."),(0,s.kt)("h3",{id:"fourchette"},"Fourchette"),(0,s.kt)("p",null,"Appel\xe9 une fois et revenu deux fois.",(0,s.kt)("br",{parentName:"p"}),"\n","Ex\xe9cution simultan\xe9e. Espace d'adressage identique mais s\xe9par\xe9. Fichiers partag\xe9s. ",(0,s.kt)("img",{alt:"img_18.png",src:n(4427).Z,width:"941",height:"325"})),(0,s.kt)("p",null,"Si un processus parent se termine, le noyau s'arrange pour que le processus init devienne le parent adoptif de ses processus orphelins. init a un PID de 1, est cr\xe9\xe9 par le noyau au d\xe9marrage du syst\xe8me, ne se termine pas et est l'anc\xeatre de tous les processus. Si le processus parent se termine sans r\xe9cup\xe9rer ses enfants morts, le noyau planifiera le processus init pour les r\xe9cup\xe9rer. Cependant, les programmes de longue dur\xe9e, tels que les shells ou les serveurs, doivent toujours recycler leurs enfants morts. M\xeame si les processus enfants morts ne sont pas en cours d'ex\xe9cution, ils consomment toujours des ressources de m\xe9moire syst\xe8me."),(0,s.kt)("p",null,"Un processus peut attendre que ses processus enfants se terminent ou s'arr\xeatent en appelant la fonction waitpid."),(0,s.kt)("p",null,"La fonction waitpid est un peu compliqu\xe9e. Par d\xe9faut (lorsque options=0), waitpid suspend l'ex\xe9cution du processus appelant jusqu'\xe0 ce que l'un de ses processus enfants dans le jeu d'attente se termine. Si l'un des processus du jeu d'attente s'est termin\xe9 au moment de l'appel, alors waitpid revient imm\xe9diatement. Dans les deux cas, waitpid renvoie le PID du processus enfant termin\xe9 qui a provoqu\xe9 le retour de waitpid. \xe0 ce stade, le processus enfant termin\xe9 a \xe9t\xe9 r\xe9cup\xe9r\xe9 et le noyau en supprime toute trace du syst\xe8me."),(0,s.kt)("p",null,"L'appartenance \xe0 la collection d'attente est d\xe9termin\xe9e par le param\xe8tre pid."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Si Pid>0, alors la collection d'attente est un processus enfant unique avec un ID de processus \xe9gal \xe0 pid."),(0,s.kt)("li",{parentName:"ul"},"Si Pid=-1, alors la collection d'attente est compos\xe9e de tous les enfants du processus parent.")),(0,s.kt)("p",null,"La variable argv pointe vers un tableau de pointeurs se terminant par null, chacun pointant vers une cha\xeene d'arguments. Par convention, argv","[0]"," est le nom du fichier cible ex\xe9cutable."),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"img_21.png",src:n(9351).Z,width:"1146",height:"740"}),' La variable envp pointe vers un tableau de pointeurs se terminant par null, chacun pointant vers une cha\xeene de variables d\'environnement, chacune \xe9tant une paire nom-valeur de la forme "nom=valeur".'),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"img_19.png",src:n(3478).Z,width:"1252",height:"816"})),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"img_22.png",src:n(7435).Z,width:"1148",height:"906"})),(0,s.kt)("p",null,"A un instant donn\xe9, l'ensemble des pages virtuelles est divis\xe9 en trois sous-ensembles disjoints."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Non allou\xe9 : pages qui n'ont pas encore \xe9t\xe9 allou\xe9es (ou cr\xe9\xe9es) par le syst\xe8me VM. Les blocs non allou\xe9s ne sont associ\xe9s \xe0 aucune donn\xe9e et n'occupent donc pas d'espace disque."),(0,s.kt)("li",{parentName:"ul"},"En cache\xa0: pages allou\xe9es qui sont actuellement mises en cache dans la m\xe9moire physique."),(0,s.kt)("li",{parentName:"ul"},"Non mis en cache\xa0: pages allou\xe9es qui ne sont pas mises en cache dans la m\xe9moire physique.")),(0,s.kt)("p",null,"Le cache SRAM repr\xe9sente les caches Ll, L2 et L3 situ\xe9s entre le CPU et la m\xe9moire principale, et le cache DRAM repr\xe9sente la m\xe9moire virtuelle. Cache DRAM pour repr\xe9senter le cache du syst\xe8me de m\xe9moire virtuelle, qui met en cache les pages virtuelles dans la m\xe9moire principale."),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"img_23.png",src:n(5187).Z,width:"1327",height:"735"})),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"\xc9tape 1 : Le processeur g\xe9n\xe8re une adresse virtuelle et la transmet \xe0 la MMU."),(0,s.kt)("li",{parentName:"ul"},"\xc9tape 2 : La MMU g\xe9n\xe8re une adresse PTE et la demande au cache/ma\xeetre."),(0,s.kt)("li",{parentName:"ul"},"\xc9tape 3 : Le cache/m\xe9moire principale renvoie le PTE \xe0 la MMU."),(0,s.kt)("li",{parentName:"ul"},"\xc9tape 4 : La MMU construit l'adresse physique et la transmet au cache/ma\xeetre."),(0,s.kt)("li",{parentName:"ul"},"\xc9tape 5 : L'ant\xe9m\xe9moire/m\xe9moire de d\xe9part renvoie le mot de donn\xe9es demand\xe9 au processeur. ",(0,s.kt)("img",{alt:"img_24.png",src:n(2878).Z,width:"934",height:"803"})),(0,s.kt)("li",{parentName:"ul"},"\xc9tapes 1 \xe0 3\xa0: Idem."),(0,s.kt)("li",{parentName:"ul"},"\xc9tape 4 : Le bit valide dans le PTE est z\xe9ro, donc la MMU d\xe9clenche une exception, passant le contr\xf4le du CPU au gestionnaire d'exception hors page dans le noyau du syst\xe8me d'exploitation."),(0,s.kt)("li",{parentName:"ul"},"\xc9tape 5 : Le gestionnaire hors page d\xe9termine la page sacrificielle dans la m\xe9moire physique et la transf\xe8re sur le disque si la page a \xe9t\xe9 modifi\xe9e."),(0,s.kt)("li",{parentName:"ul"},"\xc9tape 6 : La page du gestionnaire hors page appelle la nouvelle page et met \xe0 jour le PTE en m\xe9moire."),(0,s.kt)("li",{parentName:"ul"},"\xc9tape 7 : Le gestionnaire de page manquante revient au processus d'origine et ex\xe9cute \xe0 nouveau l'instruction qui a caus\xe9 la page manquante. le CPU renvoie l'adresse virtuelle qui a caus\xe9 la page manquante \xe0 la MMU. \xe9tant donn\xe9 que la page virtuelle est maintenant mise en cache dans la m\xe9moire physique, elle frappe et, une fois que la MMU a effectu\xe9 les \xe9tapes de la figure 9-13b, la m\xe9moire principale renvoie le mot demand\xe9 au processeur.")),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"img_25.png",src:n(3541).Z,width:"970",height:"741"})),(0,s.kt)("p",null,"Traduction d'adresse Core i7. ",(0,s.kt)("img",{alt:"img_26.png",src:n(8170).Z,width:"1047",height:"773"})),(0,s.kt)("p",null,"Mise en forme des entr\xe9es dans les tableaux de pages de niveau 1, niveau 2 ou niveau 3. N\xe9cessite un alignement de 4 Ko de la table des pages physiques. ",(0,s.kt)("img",{alt:"img_27.png",src:n(4504).Z,width:"965",height:"586"})," Lorsque P=1, le champ d'adresse contient un num\xe9ro de page physique (PPN) de 40 bits, le Format des entr\xe9es dans la table des pages de quatri\xe8me niveau. N\xe9cessite un alignement de 4 Ko de pages physiques. ! ",(0,s.kt)("a",{target:"_blank",href:n(3996).Z},"img_29.png")," Lorsque la MMU traduit chaque adresse virtuelle, elle met \xe9galement \xe0 jour les deux autres bits qui seront utilis\xe9s par le gestionnaire de pages manquantes du noyau. Chaque fois qu'une page est acc\xe9d\xe9e, la MMU d\xe9finit un bit A, appel\xe9 bit de r\xe9f\xe9rence. Le noyau peut utiliser ce bit de r\xe9f\xe9rence pour impl\xe9menter son algorithme de remplacement de page. Chaque fois qu'une page est \xe9crite, la MMU d\xe9finit le bit D, \xe9galement appel\xe9 bit de modification ou bit sale. Le bit de modification indique au noyau s'il doit r\xe9\xe9crire dans la page sacrificielle avant de copier la page de remplacement. Le noyau peut effacer le bit de r\xe9f\xe9rence ou de modification en appelant une instruction sp\xe9ciale du mode noyau."),(0,s.kt)("p",null,"Comment le Core i7 MMU utilise une table de pages \xe0 quatre niveaux pour traduire les adresses virtuelles en adresses physiques. ",(0,s.kt)("img",{alt:"img_28.png",src:n(1973).Z,width:"1114",height:"645"})),(0,s.kt)("p",null,"M\xe9moire virtuelle pour 1 processus Linux ",(0,s.kt)("img",{alt:"img_30.png",src:n(963).Z,width:"562",height:"728"})," Une zone (area) est une tranche contigu\xeb (morceau) de m\xe9moire virtuelle qui existe d\xe9j\xe0 (a \xe9t\xe9 allou\xe9e) et ces pages sont associ\xe9es d'une mani\xe8re ou d'une autre. Les segments de code, les segments de donn\xe9es, le tas, les segments de biblioth\xe8que partag\xe9e et les piles d'utilisateurs sont tous des domaines diff\xe9rents. Chaque page virtuelle qui existe est conserv\xe9e dans une certaine zone, tandis que les pages virtuelles qui n'appartiennent pas \xe0 une certaine zone n'existent pas et ne peuvent pas \xeatre r\xe9f\xe9renc\xe9es par des processus. Le noyau maintient une structure de t\xe2ches distincte (task_struct dans le code source) pour chaque processus du syst\xe8me. Les \xe9l\xe9ments de la structure de t\xe2che contiennent ou pointent vers toutes les informations dont le noyau a besoin pour ex\xe9cuter le processus (par exemple, le PID, un pointeur vers la pile utilisateur, le nom du fichier cible ex\xe9cutable et le compteur de programme). Une entr\xe9e dans la structure de la t\xe2che pointe vers mm_struct, qui d\xe9crit l'\xe9tat actuel de la m\xe9moire virtuelle. Les deux champs d'int\xe9r\xeat sont pgd et mmap, o\xf9 pgd pointe vers l'adresse de base de la table de pages de premier niveau (r\xe9pertoire global de pages), et mmap pointe vers une cha\xeene de vm_area_structs (structures de zone), o\xf9 chaque vm_area_struct d\xe9crit une zone de l'espace d'adressage virtuel actuel. Lorsque le noyau ex\xe9cute ce processus, il stocke le pgd dans le registre de contr\xf4le CR3. \\ vm_start : pointe vers le d\xe9but de cette zone. \\ vm_end : pointe vers la fin de cette r\xe9gion. \\ vm_prot\xa0: d\xe9crit les autorisations de lecture et d'\xe9criture pour toutes les pages contenues dans cette r\xe9gion. \\ vm_flags\xa0: d\xe9crit si les pages de cette r\xe9gion sont partag\xe9es avec d'autres processus ou sont priv\xe9es pour ce processus (d\xe9crit \xe9galement d'autres informations). \\ vm_next\xa0: pointe vers la structure de r\xe9gion suivante dans la cha\xeene. \\ ",(0,s.kt)("img",{alt:"img_31.png",src:n(6868).Z,width:"952",height:"663"})),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"img_32.png",src:n(4886).Z,width:"785",height:"597"})),(0,s.kt)("p",null,"Le chargement et l'ex\xe9cution de a.out n\xe9cessitent les \xe9tapes suivantes. 1.",(0,s.kt)("strong",{parentName:"p"},"Supprimer la zone utilisateur d\xe9j\xe0 existante."),"Supprimez la structure de r\xe9gion existante dans la partie utilisateur de l'adresse virtuelle du processus actuel. 2.",(0,s.kt)("strong",{parentName:"p"},"Cartographier les zones priv\xe9es."),"Cr\xe9ez de nouvelles structures de zone pour les zones de code, de donn\xe9es, de bss et de pile du nouveau programme. Toutes ces nouvelles zones sont priv\xe9es, en copie sur \xe9criture. Les zones de code et de donn\xe9es sont mapp\xe9es sur les zones .text et .stack du fichier a.out. texte et. La zone bss est demand\xe9e pour les z\xe9ros binaires et est mapp\xe9e sur un fichier anonyme dont la taille est contenue dans a.out. Les r\xe9gions de pile et de tas demandent \xe9galement des z\xe9ros binaires et ont une longueur initiale de z\xe9ro. La figure 9-31 r\xe9sume les diff\xe9rents mappages de r\xe9gions priv\xe9es. 3. 3.",(0,s.kt)("strong",{parentName:"p"},"Cartographie des zones partag\xe9es."),"Si le programme a.out est li\xe9 \xe0 un objet partag\xe9 (ou cible), comme la biblioth\xe8que C standard libc.so, alors ces objets sont dynamiquement li\xe9s \xe0 ce programme puis mapp\xe9s dans une zone partag\xe9e dans l'espace d'adressage virtuel de l'utilisateur . 4.",(0,s.kt)("strong",{parentName:"p"},"R\xe9glez le compteur de programme (PC). La derni\xe8re chose que fait"),"execve est de d\xe9finir le compteur de programme dans le contexte du processus en cours pour qu'il pointe vers le point d'entr\xe9e de la zone de code."),(0,s.kt)("p",null," ",(0,s.kt)("img",{alt:"img_33.png",src:n(424).Z,width:"445",height:"596"})),(0,s.kt)("p",null,"1.",(0,s.kt)("strong",{parentName:"p"},"alternateur explicite"),", qui oblige l'application \xe0 lib\xe9rer explicitement tous les blocs allou\xe9s. Par exemple, la biblioth\xe8que standard C fournit un alternateur explicite appel\xe9 package malloc. Les op\xe9rateurs new et delete en C++ sont \xe9quivalents \xe0 malloc et free en C. 2. 2.",(0,s.kt)("strong",{parentName:"p"},"l'allocateur implicite"),", d'autre part, exige que l'allocateur d\xe9tecte quand un bloc allou\xe9 n'est plus utilis\xe9 par le programme, puis lib\xe8re le bloc. Un alternateur implicite est \xe9galement appel\xe9",(0,s.kt)("strong",{parentName:"p"},"ramasse-miettes"),", et le processus de lib\xe9ration automatique des blocs allou\xe9s inutilis\xe9s est appel\xe9",(0,s.kt)("strong",{parentName:"p"},"ramasse-miettes"),". Les langages de haut niveau tels que Lisp, ML et Java, par exemple, s'appuient sur la r\xe9cup\xe9ration de place pour lib\xe9rer les blocs allou\xe9s."),(0,s.kt)("p",null,"La fonction malloc renvoie un pointeur vers un bloc de m\xe9moire d'au moins taille octets, qui est align\xe9 pour tous les types d'objets de donn\xe9es pouvant \xeatre contenus dans le bloc. En pratique, l'alignement d\xe9pend du fait que le code compil\xe9 s'ex\xe9cute en mode 32 bits (gcc -m32) ou en mode 64 bits (valeur par d\xe9faut). En mode 32 bits, l'adresse du bloc renvoy\xe9e par malloc est toujours un multiple de 8. En mode 64 bits, l'adresse est toujours un multiple de 16. La fonction sbrk \xe9tend et r\xe9duit le tas en ajoutant incr au pointeur brk du noyau. S'il r\xe9ussit, il renvoie l'ancienne valeur de brk, sinon il renvoie -1 et d\xe9finit errno sur ENOMEM. sbrk renvoie la valeur actuelle de brk si incr vaut z\xe9ro. Appeler sbrk avec un incr n\xe9gatif est l\xe9gal et intelligent car la valeur de retour (l'ancienne valeur de brk) pointe vers abs(incr) octets \xe0 partir du haut du nouveau tas. Le programme lib\xe8re le bloc de tas allou\xe9 en appelant la fonction free. ",(0,s.kt)("img",{alt:"img_34.png",src:n(7190).Z,width:"553",height:"649"})," a : Le programme demande un bloc de 4 mots. malloc r\xe9pond en coupant un bloc de 4 mots \xe0 l'avant du bloc libre et en renvoyant un pointeur sur le premier mot du bloc. b : Le programme demande un bloc de 5 mots. malloc r\xe9pond en allouant un bloc de 6 mots \xe0 partir de l'avant du bloc libre. Dans ce cas, malloc remplit le bloc avec un mot suppl\xe9mentaire, afin de garder le bloc libre align\xe9 sur la limite du double mot. c : Le programme demande un bloc de 6 mots et malloc coupe un bloc de 6 mots \xe0 l'avant du bloc libre. d : Le programme lib\xe8re le bloc de 6 caract\xe8res attribu\xe9 en b. Notez qu'apr\xe8s le retour de l'appel \xe0 free, le pointeur p2 pointe toujours sur le bloc lib\xe9r\xe9. Il est de la responsabilit\xe9 de l'application de ne plus utiliser p2 jusqu'\xe0 ce qu'il soit r\xe9initialis\xe9 par un nouvel appel malloc. e : Le programme demande un bloc de 2 caract\xe8res. Dans ce cas, malloc alloue une partie du bloc lib\xe9r\xe9 \xe0 l'\xe9tape pr\xe9c\xe9dente et renvoie un pointeur vers ce nouveau bloc."),(0,s.kt)("p",null,"Contraintes d'allocation explicites. 1.",(0,s.kt)("strong",{parentName:"p"},"G\xe9rer des s\xe9quences arbitraires de requ\xeates.")," Une application peut avoir une s\xe9quence arbitraire de demandes d'allocation et de lib\xe9ration, tant que la contrainte est satisfaite\xa0: chaque demande de lib\xe9ration doit correspondre \xe0 un bloc actuellement allou\xe9 qui a \xe9t\xe9 obtenu \xe0 partir d'une demande d'allocation pr\xe9c\xe9dente. Ainsi, l'allocateur ne peut pas supposer une s\xe9quence de demandes d'allocation et de lib\xe9ration. Par exemple, l'allocateur ne peut pas supposer que toutes les demandes d'allocation ont des demandes de lib\xe9ration correspondantes, ou qu'il existe des demandes d'allocation et de lib\xe9ration correspondantes qui sont imbriqu\xe9es. 2.",(0,s.kt)("strong",{parentName:"p"},"R\xe9ponse imm\xe9diate aux demandes.")," Les allocataires doivent r\xe9pondre imm\xe9diatement aux demandes d'allocation. Par cons\xe9quent, l'allocateur n'est pas autoris\xe9 \xe0 r\xe9organiser ou mettre en m\xe9moire tampon les demandes pour am\xe9liorer les performances. 3.",(0,s.kt)("strong",{parentName:"p"},"Utilisez uniquement le tas."),"Pour que l'allocateur soit \xe9volutif, toutes les structures de donn\xe9es non scalaires utilis\xe9es par l'allocateur doivent \xeatre stock\xe9es dans le tas. 4.",(0,s.kt)("strong",{parentName:"p"},"Aligner les blocs (exigences d'alignement)."),"Les r\xe9partiteurs doivent aligner les blocs afin qu'ils puissent contenir n'importe quel type d'objet de donn\xe9es. 5.",(0,s.kt)("strong",{parentName:"p"},"Ne modifiez pas les blocs allou\xe9s."),"Les allocators ne peuvent manipuler ou modifier que des blocs libres. En particulier, une fois qu'un bloc a \xe9t\xe9 allou\xe9, il ne peut plus \xeatre modifi\xe9 ou d\xe9plac\xe9. Par cons\xe9quent, les techniques telles que la compression des blocs allou\xe9s ne sont pas autoris\xe9es."),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"img_35.png",src:n(4407).Z,width:"837",height:"332"}),"Le format d'un bloc de tas simple Si nous imposons une contrainte d'alignement de mots doubles, alors la taille du bloc est toujours un multiple de 8 et les 3 bits les plus bas de la taille du bloc sont toujours nuls. Par cons\xe9quent, nous n'avons besoin que des 29 bits de poids fort de la taille de la m\xe9moire et lib\xe9rons les 3 bits restants pour encoder d'autres informations. Dans ce cas, nous utilisons le bit le plus bas (le bit allou\xe9) pour indiquer si le bloc est allou\xe9 ou libre. Par exemple, supposons que nous ayons un bloc allou\xe9 d'une taille de 24 (0x18) octets. Ensuite, son en-t\xeate sera"),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"0x00000018 | 0x1 = 0x00000019")),(0,s.kt)("p",null,"De m\xeame, un bloc libre avec une taille de bloc de 40 (0x28) octets a l'en-t\xeate suivant."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"0x00000028 | 0x0 = 0x00000028")),(0,s.kt)("p",null,"Apr\xe8s l'en-t\xeate se trouve la charge utile demand\xe9e par l'application lorsque malloc est appel\xe9. La charge utile est suivie d'un morceau de remplissage inutilis\xe9, qui peut \xeatre de taille arbitraire. Le rembourrage est n\xe9cessaire pour un certain nombre de raisons. Par exemple, le remplissage peut faire partie d'une strat\xe9gie d'allocation pour faire face \xe0 la fragmentation externe. Ou il peut \xe9galement \xeatre n\xe9cessaire pour r\xe9pondre aux exigences d'alignement."),(0,s.kt)("p",null,(0,s.kt)("img",{alt:"img_36.png",src:n(6540).Z,width:"1104",height:"160"})," Organisez le tas avec une table de liens libres implicites. Les parties ombr\xe9es sont des blocs allou\xe9s. La partie non ombr\xe9e est le bloc libre. L'en-t\xeate est marqu\xe9 (taille en octets / bits allou\xe9s) puis la taille de chaque bloc doit \xeatre un multiple d'un mot double (8 octets). Ainsi, il en r\xe9sulte une taille de bloc minimale de deux mots : un mot pour l'en-t\xeate et un autre mot pour maintenir les exigences d'alignement. M\xeame si l'application ne demande qu'un seul octet, l'allocateur doit toujours cr\xe9er un bloc de deux mots. L'avantage d'une table de liens libres implicites est sa simplicit\xe9. L'inconv\xe9nient majeur est que la surcharge de toute op\xe9ration, telle que le placement d'un bloc allou\xe9, n\xe9cessite une recherche dans la table de cha\xeene inactive, et le temps requis pour cette recherche est lin\xe9airement li\xe9 au nombre total de blocs allou\xe9s et inactifs dans le tas."))}m.isMDXComponent=!0},3996:function(e,t,n){t.Z=n.p+"assets/files/img_29-88bbd4f26421bac9f1c4acedc0cab88d.png"},7810:function(e,t,n){t.Z=n.p+"assets/images/img_11-a6b1ee91d133ea85c07ca53796d56865.png"},9136:function(e,t,n){t.Z=n.p+"assets/images/img_12-293f1e45dbefd4492a52f68b76430af4.png"},3777:function(e,t,n){t.Z=n.p+"assets/images/img_13-18afad785386bd7d289486e98768268d.png"},80:function(e,t,n){t.Z=n.p+"assets/images/img_14-66f20dc214a17879306ea7e74f4721b7.png"},4070:function(e,t,n){t.Z=n.p+"assets/images/img_15-eb87aac9eabd1852657d1106ded68be2.png"},5834:function(e,t,n){t.Z=n.p+"assets/images/img_16-0fa205ab6ed1df8ff13ffd36d3ac28fa.png"},6519:function(e,t,n){t.Z=n.p+"assets/images/img_17-3b89551411862ef4cd85ef912501cf87.png"},4427:function(e,t,n){t.Z=n.p+"assets/images/img_18-c3004995acf19ac52ee25577e6bc0d99.png"},3478:function(e,t,n){t.Z=n.p+"assets/images/img_19-e7f161697e246df5430dd6169a0228cb.png"},9351:function(e,t,n){t.Z=n.p+"assets/images/img_21-05b28cdf75bce2df17eadcd5b1aa2b12.png"},7435:function(e,t,n){t.Z=n.p+"assets/images/img_22-75dc9173287ee640b66c6560a7a95c6b.png"},5187:function(e,t,n){t.Z=n.p+"assets/images/img_23-49a90da73609d0273c04516dcd327695.png"},2878:function(e,t,n){t.Z=n.p+"assets/images/img_24-b4098c54b31796997de1ed444f427b4f.png"},3541:function(e,t,n){t.Z=n.p+"assets/images/img_25-b91f2762afcca85898a1350b9986854f.png"},8170:function(e,t,n){t.Z=n.p+"assets/images/img_26-d102c4ed20c54c6769f68be82735839f.png"},4504:function(e,t,n){t.Z=n.p+"assets/images/img_27-d0eb480bd01628bb868640e592d3ad59.png"},1973:function(e,t,n){t.Z=n.p+"assets/images/img_28-cf66700a7b2d28896cefa1b1cd5ae0d3.png"},963:function(e,t,n){t.Z=n.p+"assets/images/img_30-5ff70a02f1be3297c3ac21eca995ce51.png"},6868:function(e,t,n){t.Z=n.p+"assets/images/img_31-20645c7ae6e5a6d6b7a93bbf9b83a900.png"},4886:function(e,t,n){t.Z=n.p+"assets/images/img_32-d20b74dd11209a8e4dadf52bfb33b58a.png"},424:function(e,t,n){t.Z=n.p+"assets/images/img_33-391303c425b206adff0429f2fe6d4c3b.png"},7190:function(e,t,n){t.Z=n.p+"assets/images/img_34-1034c631a991255000ee0d5065dcaa9a.png"},4407:function(e,t,n){t.Z=n.p+"assets/images/img_35-3394a44b4a0f939965192b20f8aef179.png"},6540:function(e,t,n){t.Z=n.p+"assets/images/img_36-1a6fbc79a2945ec93bd879e2a377fa1d.png"}}]);